{"mappings":";;;;;;;;;;AAAA,sDAAsD;AACtD,4FAA4F;AAC5F,wBAAwB;AACxB,EAAE;AACF,wBAAwB;AACxB,2HAA2H;AAC3H,gGAAgG;AAChG,0DAA0D;AAC1D,MAAM;AACN,8DAA8D;AAC9D,yEAAyE;AACzE,UAAU;AACV,MAAM;AACN,iHAAiH;AACjH,8GAA8G;AAC9G,kGAAkG;AAClG,oHAAoH;AACpH,2GAA2G;AAC3G,sGAAsG;AACtG,EAAE;AACF,oFAAoF;AACpF,2DAA2D;AAC3D,EAAE;;;;;;;ACnBF,MAAM,4CAAK,CAAA,GAAA,aAAK,EAAE;IAChB,SAAS;QAAC,CAAA,GAAA,aAAK,EAAE;YACf,MAAM;QACR;KAAG;IACH,OAAO,CAAA,GAAA,YAAI;AACb;;;;AENA,IAAI,8BAAQ;AAGkC;IAC5C,MAAM,iBAAiB,KAAK,KAAK,CAAC,GAAG,YAAY,kBAA2C;IAC5F,8BAAQ,CAAA,GAAA,oBAAY,EAAE,aAAa,CAAC;QAClC,YAAY,4BAAM,UAAU,CAAC,IAAI,CAAC,eAAe,OAAO;IAC1D;AACF,KAIA,2CAAe;;;ADXR,MAAM,4CAAe,OAAO,KAAK,KAAK;IAG3C,MAAM,QAAQ,IAAI,OAAO,CAAC,aAAa,EAAE,MAAM,UAAU,CAAC,EAAE;IAC5D,IAAI,CAAC,OAAO,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;QAAE,OAAO;IAAe;IAEhE,IAAI;QACF,IAAI,IAAI,GAAG,MAAM,CAAA,GAAA,wCAAI,EAAE,IAAI,GAAG,aAAa,CAAC;QAC5C;IACF,EAAE,OAAM;QACN,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAe;IAC/C;AACF;;;;AEbA,MAAM,4CAAsB;IAAC;IAAO;IAAO;IAAQ;IAAQ;IAAO;CAAO;AAEzE,+EAA+E;AAC/E,MAAM,4CAAS,CAAA,GAAA,aAAK,EAAE;IACpB,SAAS,CAAA,GAAA,aAAK,EAAE,aAAa;IAC7B,QAAQ;QAAE,UAAU;IAAiB;IACrC,YAAY,CAAC,KAAK,MAAM;QACtB,MAAM,UAAU,0CAAoB,QAAQ,CAC1C,KAAK,YAAY,CAAC,KAAK,CAAC,KAAK,GAAG,GAAG,WAAW;QAEhD,GAAG,MAAM;IACX;AACF;;;;AJkBA,4CAA4C;AAC5C,CAAA,GAAA,aAAK,EAAE,MAAM;AAEb,MAAM,2CAAM,CAAA,GAAA,cAAM;AAClB,MAAM;AAEN,0CAA0C;AAC1C,yCAAI,GAAG,CAAC,CAAA,GAAA,cAAM,EAAE,IAAI;AAEpB,4BAA4B;AAC5B,yCAAI,GAAG,CAAC,KAAK,CAAC,KAAK;IACjB,IAAI,IAAI,CAAC;AACX;AAEA,kDAAkD;AAClD,MAAM;IACJ,aAAc;QACZ,IAAI,CAAC,QAAQ,GAAG,IAAI;IACtB;IACA,MAAM,IAAI,SAAS,EAAE;QACnB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;IAC3B;IACA,MAAM,KAAK,SAAS,EAAE,IAAI,EAAE;QAC1B,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW;IAC/B;AACF;AAEA,MAAM,qCAAe,IAAI;AAEzB;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD,yCAAI,IAAI,CAAC,gBAAgB,CAAA,GAAA,yCAAW,GAAG,OAAO,KAAK;IACjD,IAAI;QACF,MAAM,aAAE,SAAS,WAAE,OAAO,EAAE,GAAG,IAAI,IAAI;QACvC,IAAI,CAAC,SACH,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA2B;QAGlE,0DAA0D;QAC1D,IAAI,UAAU,YACV,MAAM,CAAA,GAAA,yCAAC,EAAE,WAAW,CAAC,WAAW;YAAE,OAAO;QAAa,KACtD;QACJ,IAAI,CAAC,SACH,UAAU,CAAA,GAAA,yCAAC,EAAE,aAAa,CAAC;YAAE,OAAO;QAAa;QAGnD,qCAAqC;QACrC,MAAM,OAAO,QAAQ,IAAI,CAAC;YACxB,OAAO,CAAA,GAAA,0DAAI;YACX,QAAQ;QACV;QAEA,0BAA0B;QAC1B,MAAM,WAAW,MAAM,KAAK,IAAI,CAAC;QAEjC,2EAA2E;QAC3E,IAAI,IAAI,CAAC;YAAE,OAAO,SAAS,IAAI;YAAE,WAAW,QAAQ,EAAE;QAAC;IACzD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO,sCAAsC,MAAM,OAAO;QAAC;IACpF;AACF;AAEA;;;;;;;;;;;;;;;CAeC,GACD,yCAAI,IAAI,CAAC,kBAAkB,CAAA,GAAA,yCAAW,GAAG,CAAC,KAAK;IAC7C,CAAA,GAAA,yCAAK,EAAE,MAAM,CAAC,SAAS,KAAK,KAAK,OAAO;QACtC,IAAI,KAAK;YACP,MAAM,MAAM,eAAe,CAAA,GAAA,yDAAK,EAAE,WAAW,GACzC,CAAC,mBAAmB,EAAE,IAAI,OAAO,EAAE,GACnC,IAAI,OAAO;YACf,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAI;QAC3C;QACA,IAAI,CAAC,IAAI,IAAI,EACX,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA6C;QAGpF,IAAI;YACF,MAAM,OAAO,IAAI,CAAA,GAAA,eAAO;YACxB,KAAK,MAAM,CAAC,QAAQ,IAAI,IAAI,CAAC,MAAM,EAAE;gBACnC,UAAU,IAAI,IAAI,CAAC,YAAY;gBAC/B,aAAa,IAAI,IAAI,CAAC,QAAQ;YAChC;YACA,KAAK,MAAM,CAAC,SAAS;YAErB,MAAM,kBAAkB,MAAM,CAAA,GAAA,YAAI,EAAE,IAAI,CACtC,kDACA,MACA;gBACE,SAAS;oBACP,eAAe,CAAC,OAAO,0KAA8B;oBACrD,GAAG,KAAK,UAAU,EAAE;gBACtB;YACF;YAEF,IAAI,IAAI,CAAC;gBAAE,eAAe,gBAAgB,IAAI,CAAC,IAAI;YAAC;QACtD,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,kBAAkB,MAAM,QAAQ,EAAE,QAAQ,MAAM,OAAO;YACrE,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAAoC;QACpE;IACF;AACF;AAGqC;IACnC,MAAM,SAAS,yCAAI,MAAM,CAAC,4BAAM;QAC9B,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,4BAAM;IAC5D;IAEA,oBAAoB;IACpB,UAAW,WAAW;QACpB,QAAQ,GAAG,CAAC;QACZ,OAAO,KAAK,CAAC;YACX,QAAQ,GAAG,CAAC;QACd;IACF;AACF","sources":["index.js","config/genkit.js","middleware/auth.js","config/firebase.js","middleware/upload.js"],"sourcesContent":["// We use `ai.chat()` to create a conversation session\r\n// and `chat.send()` to send messages and get responses. This allows maintaining an internal\r\n// conversation context.\r\n//\r\n// Assurances and notes:\r\n// - The client continues to maintain history on the client side: with each POST request, the client sends both the current\r\n//   user message and the entire \"history\" (past conversation). The server rebuilds the context.\r\n// - This example assumes that the \"history\" has the form:\r\n//   [\r\n//     { \"role\": \"user\", \"content\": \"previous user message\" },\r\n//     { \"role\": \"assistant\", \"content\": \"previous assistant response\" },\r\n//     ...\r\n//   ]\r\n// - To rebuild the context, the server replays the user messages from history by calling `chat.send()` for each.\r\n//   This will make the model regenerate the assistant's responses. They might differ from those in history if\r\n//   persistence methods or deterministic seeds aren't used. However, this provides the model with\r\n//   a coherent history. The user will need to handle these aspects at the client level or integrate a SessionStore.\r\n// - The approach shown is simplified: if you want to maintain exactly the original conversation (including\r\n//   assistant responses), you need additional tools (e.g., `SessionStore`), not shown in detail here.\r\n//\r\n// Besides this, we also maintain the audio transcription endpoint shown previously,\r\n// now the \"converse\" part simply uses Genkit's chat logic.\r\n//\r\n\r\nimport express from \"express\"\r\nimport dotenv from \"dotenv\"\r\nimport axios from \"axios\"\r\nimport FormData from \"form-data\"\r\nimport { ai, gpt4o } from \"./config/genkit.js\"\r\nimport { authenticate } from \"./middleware/auth.js\"\r\nimport { upload, multer } from \"./middleware/upload.js\"\r\n\r\n// Load environment variables from .env file\r\ndotenv.config()\r\n\r\nconst app = express()\r\nconst port = process.env.PORT || 3000\r\n\r\n// Middleware to parse JSON request bodies\r\napp.use(express.json())\r\n\r\n// Simple health check route\r\napp.get(\"/\", (req, res) => {\r\n  res.send(\"Hello! This server uses Genkit for conversation.\")\r\n})\r\n\r\n// A very simple example session store in memory. \r\nclass InMemorySessionStore {\r\n  constructor() {\r\n    this.sessions = new Map()\r\n  }\r\n  async get(sessionId) {\r\n    return this.sessions.get(sessionId)\r\n  }\r\n  async save(sessionId, data) {\r\n    this.sessions.set(sessionId, data)\r\n  }\r\n}\r\n\r\nconst sessionStore = new InMemorySessionStore()\r\n\r\n/**\r\n * POST /ai/converse\r\n * Request JSON format:\r\n * {\r\n *   \"sessionId\": string,  // Optional: The session ID to continue an existing conversation.\r\n *   \"message\": string     // Required: The current message to send to the AI.\r\n * }\r\n * \r\n * Response JSON format:\r\n * {\r\n *   \"reply\": string,      // The AI's response text.\r\n *   \"sessionId\": string   // The session ID for the current conversation (use this for subsequent requests).\r\n * }\r\n * or\r\n * {\r\n *   \"error\": string       // Error message if the request fails.\r\n * }\r\n * \r\n * Notes:\r\n * - If \"sessionId\" is provided, the server will attempt to continue the conversation from the given session.\r\n * - If \"sessionId\" is not provided or invalid, a new session will be created, and its ID will be returned.\r\n * - The client should persist and reuse the \"sessionId\" to maintain conversation context across requests.\r\n */\r\napp.post(\"/ai/converse\", authenticate, async (req, res) => {\r\n  try {\r\n    const { sessionId, message } = req.body\r\n    if (!message) {\r\n      return res.status(400).json({ error: 'Missing \"message\" field.' })\r\n    }\r\n\r\n    // Try to load existing session; if none, create a new one\r\n    let session = sessionId\r\n      ? await ai.loadSession(sessionId, { store: sessionStore })\r\n      : null\r\n    if (!session) {\r\n      session = ai.createSession({ store: sessionStore })\r\n    }\r\n\r\n    // Create a chat tied to this session\r\n    const chat = session.chat({\r\n      model: gpt4o,\r\n      system: \"You are a helpful assistant. Respond in a friendly and helpful way.\"\r\n    })\r\n\r\n    // Send the userâ€™s message\r\n    const response = await chat.send(message)\r\n\r\n    // Return AI response + the session ID (so client can persist conversation)\r\n    res.json({ reply: response.text, sessionId: session.id })\r\n  } catch (error) {\r\n    console.error(\"Error in /ai/converse:\", error)\r\n    res.status(500).json({ error: \"Error while generating response: \" + error.message })\r\n  }\r\n})\r\n\r\n/**\r\n * POST /ai/transcribe\r\n * Request format: multipart/form-data\r\n * Fields:\r\n * - audio: File      // Required: Audio file to transcribe\r\n * \r\n * Response JSON format:\r\n * {\r\n *   \"transcription\": string    // The transcribed text\r\n * }\r\n * or\r\n * {\r\n *   \"error\": string,          // Error message if request fails\r\n *   \"details\"?: string        // Optional detailed error info\r\n * }\r\n */\r\napp.post(\"/ai/transcribe\", authenticate, (req, res) => {\r\n  upload.single(\"audio\")(req, res, async (err) => {\r\n    if (err) {\r\n      const msg = err instanceof multer.MulterError\r\n        ? `File upload error: ${err.message}`\r\n        : err.message\r\n      return res.status(400).json({ error: msg })\r\n    }\r\n    if (!req.file) {\r\n      return res.status(400).json({ error: 'No audio file provided. Use \"audio\" field.' })\r\n    }\r\n\r\n    try {\r\n      const form = new FormData()\r\n      form.append(\"file\", req.file.buffer, {\r\n        filename: req.file.originalname,\r\n        contentType: req.file.mimetype\r\n      })\r\n      form.append(\"model\", \"whisper-1\")\r\n\r\n      const whisperResponse = await axios.post(\r\n        \"https://api.openai.com/v1/audio/transcriptions\",\r\n        form,\r\n        {\r\n          headers: {\r\n            Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,\r\n            ...form.getHeaders()\r\n          }\r\n        }\r\n      )\r\n      res.json({ transcription: whisperResponse.data.text })\r\n    } catch (error) {\r\n      console.error(\"Error details:\", error.response?.data || error.message)\r\n      res.status(500).json({ error: \"Error during audio transcription.\" })\r\n    }\r\n  })\r\n})\r\n\r\n// Start the server in non-test environments\r\nif (process.env.NODE_ENV !== \"test\") {\r\n  const server = app.listen(port, () => {\r\n    console.log(`Server listening on http://localhost:${port}`)\r\n  })\r\n\r\n  // Graceful shutdown\r\n  process.on(\"SIGTERM\", () => {\r\n    console.log(\"SIGTERM received; closing server...\")\r\n    server.close(() => {\r\n      console.log(\"Server closed.\")\r\n    })\r\n  })\r\n}\r\n\r\nexport { app }\r\n","import { genkit } from 'genkit';\r\nimport { openAI, gpt4o } from 'genkitx-openai';\r\n\r\nconst ai = genkit({\r\n  plugins: [openAI({\r\n    apiKey: process.env.OPENAI_API_KEY\r\n  })],\r\n  model: gpt4o\r\n});\r\n\r\nexport { ai, gpt4o };","import admin from '../config/firebase.js';\r\n\r\n// Authentication middleware to verify Firebase ID token\r\nexport const authenticate = async (req, res, next) => {\r\n  if (process.env.NODE_ENV === 'test') return next();\r\n\r\n  const token = req.headers.authorization?.split('Bearer ')[1];\r\n  if (!token) return res.status(401).json({ error: 'Unauthorized' });\r\n\r\n  try {\r\n    req.user = await admin.auth().verifyIdToken(token);\r\n    next();\r\n  } catch {\r\n    res.status(401).json({ error: 'Unauthorized' });\r\n  }\r\n};","import firebaseAdmin from 'firebase-admin';\r\n\r\nlet admin = null;\r\n\r\n// Configure firebase admin SDK\r\nif (process.env.FIREBASE_SERVICE_ACCOUNT_KEY) {\r\n  const serviceAccount = JSON.parse(fs.readFileSync(process.env.FIREBASE_SERVICE_ACCOUNT_KEY, 'utf8'));\r\n  admin = firebaseAdmin.initializeApp({\r\n    credential: admin.credential.cert(serviceAccount.default)\r\n  });\r\n} else {\r\n  console.warn('Firebase service account not configured');\r\n}\r\n\r\nexport default admin;","import multer from 'multer';\r\n\r\nconst VALID_AUDIO_FORMATS = ['mp3', 'mp4', 'mpeg', 'mpga', 'wav', 'webm'];\r\n\r\n// Multer is a middleware for handling multipart/form-data when uploading files\r\nconst upload = multer({\r\n  storage: multer.memoryStorage(), // Use memory storage to avoid file system operations\r\n  limits: { fileSize: 25 * 1024 * 1024 }, // 25mb\r\n  fileFilter: (req, file, cb) => {\r\n    const isValid = VALID_AUDIO_FORMATS.includes(\r\n      file.originalname.split('.').pop().toLowerCase()\r\n    );\r\n    cb(null, isValid);\r\n  }\r\n});\r\n\r\nexport { multer, upload };"],"names":[],"version":3,"file":"backend.js.map"}